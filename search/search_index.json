{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-expressive-flash Provides flash messages for PSR-7 middleware using zend-expressive-session . Installation Run the following to install this library: $ composer require zendframework/zend-expressive-flash Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"zend-expressive-flash"},{"location":"#zend-expressive-flash","text":"Provides flash messages for PSR-7 middleware using zend-expressive-session .","title":"zend-expressive-flash"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-flash","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"intro/","text":"zend-expressive-flash Flash messages are self-expiring, session-based messages. They are typically used when when you need to redirect after processing a request (e.g., when using the Post-Redirect-Get pattern ), but want to display a message back to the user indicating a processing result. As an example, I may want to display a \"Thank You\" message to the user after successfully completing a form. I can do that with flash messages. When processing, I would create the message in my middleware: $flashMessages->flash('form-complete', 'Thank you; your submission was recorded.'); On the subsequent request, my middleware would pull that message: $message = $flashMessages->getFlash('form-complete'); On any subsequent requests, the message is no longer available! Installation To use the component, install via Composer : $ composer require zendframework/zend-expressive-flash Persistence required zend-expressive-flash depends on zend-expressive-session, which defines abstractions around session containers \u2014 for use within applications for accessing session data \u2014 and session persistence (how the session data is persisted between requests, and reported to the client). Persistence requires a persistence adapter . We offer one basd on PHP's session extension via the package zend-expressive-session-ext; others may also be available soon.","title":"Introduction"},{"location":"intro/#zend-expressive-flash","text":"Flash messages are self-expiring, session-based messages. They are typically used when when you need to redirect after processing a request (e.g., when using the Post-Redirect-Get pattern ), but want to display a message back to the user indicating a processing result. As an example, I may want to display a \"Thank You\" message to the user after successfully completing a form. I can do that with flash messages. When processing, I would create the message in my middleware: $flashMessages->flash('form-complete', 'Thank you; your submission was recorded.'); On the subsequent request, my middleware would pull that message: $message = $flashMessages->getFlash('form-complete'); On any subsequent requests, the message is no longer available!","title":"zend-expressive-flash"},{"location":"intro/#installation","text":"To use the component, install via Composer : $ composer require zendframework/zend-expressive-flash","title":"Installation"},{"location":"intro/#persistence-required","text":"zend-expressive-flash depends on zend-expressive-session, which defines abstractions around session containers \u2014 for use within applications for accessing session data \u2014 and session persistence (how the session data is persisted between requests, and reported to the client). Persistence requires a persistence adapter . We offer one basd on PHP's session extension via the package zend-expressive-session-ext; others may also be available soon.","title":"Persistence required"},{"location":"messages/","text":"Flash Messages Flash messages are contained within a Zend\\Expressive\\Flash\\FlashMessagesInterface implementation. That interface is defined as follows: namespace Zend\\Expressive\\Flash; use Zend\\Expressive\\Session\\SessionInterface; interface FlashMessagesInterface { /** * Flash values scheduled for next request. */ public const FLASH_NEXT = self::class . '::FLASH_NEXT'; /** * Create an instance from a session container. * * Flash messages will be retrieved from and persisted to the session via * the `$sessionKey`. */ public static function createFromSession( SessionInterface $session, string $sessionKey = self::FLASH_NEXT ) : FlashMessagesInterface; /** * Set a flash value with the given key. * * Flash values are accessible on the next \"hop\", where a hop is the * next time the session is accessed; you may pass an additional $hops * integer to allow access for more than one hop. * * @param mixed $value */ public function flash(string $key, $value, int $hops = 1) : void; /** * Set a flash value with the given key, but allow access during this request. * * Flash values are generally accessible only on subsequent requests; * using this method, you may make the value available during the current * request as well. * * @param mixed $value */ public function flashNow(string $key, $value, int $hops = 1) : void; /** * Retrieve a flash value. * * Will return a value only if a flash value was set in a previous request, * or if `flashNow()` was called in this request with the same `$key`. * * WILL NOT return a value if set in the current request via `flash()`. * * @param mixed $default Default value to return if no flash value exists. * @return mixed */ public function getFlash(string $key, $default = null); /** * Retrieve all flash values. * * Will return all values was set in a previous request, or if `flashNow()` * was called in this request. * * WILL NOT return values set in the current request via `flash()`. * * @return array */ public function getFlashes() : array; /** * Clear all flash values. * * Affects the next and subsequent requests. */ public function clearFlash() : void; /** * Prolongs any current flash messages for one more hop. */ public function prolongFlash() : void; } A default implementation is provided in the class Zend\\Expressive\\Flash\\FlashMessages , but you may implement the interface yourself if you have special needs that fall outside this standard implementation. The instance will generally be injected into your request under the attribute Zend\\Expressive\\Flash\\FlashMessageMiddleware::FLASH_ATTRIBUTE , which evaluates to flash . Usage First, pull the flash messages from the request: $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE); // or $flashMessages = $request->getAttribute('flash'); To create a flash message for the next request: $flashMessages->flash($messageName, $messageValue); To retrieve a message you previously flashed: $message = $flashMessages->getFlash($messageName); To retrieve all messages you previously flashed: $messages = $flashMessages->getFlashes(); Hops Sometimes you may want a flash message to persist for longer than a single request. As an example, with a multi-page form, you may want to store messages until all pages have been filled. zend-expressive-flash allows you to specify hops , indicating how many requests the flash message will persist for. The default value is 1 , indicating a single hop. This value is provided when you call flash() as an optional third argument. To have a message persist for three \"hops\", you might call flash() as follows: $flashMessages->flash($messageName, $messageValue, 3); Sometimes you may want to ensure all messages persist for one more hop. To do that: $flashMessages->prolongFlash(); If you want to clear all flash methods, no matter the number of hops: $flashMessages->clearFlash(); Note, however, that this clears them for the next request , not the current one. Accessing messages in the current request When you create a flash message, it is available in the next request , but not the current request . If you want access to it in the current request as well, use the flashNow() method instead of flash() : $flashMessages->flashNow($messageName, $messageValue); The signature of this method is the same as for flash() , and allows you to optionally provide a $hops value as well.","title":"Flash Messages"},{"location":"messages/#flash-messages","text":"Flash messages are contained within a Zend\\Expressive\\Flash\\FlashMessagesInterface implementation. That interface is defined as follows: namespace Zend\\Expressive\\Flash; use Zend\\Expressive\\Session\\SessionInterface; interface FlashMessagesInterface { /** * Flash values scheduled for next request. */ public const FLASH_NEXT = self::class . '::FLASH_NEXT'; /** * Create an instance from a session container. * * Flash messages will be retrieved from and persisted to the session via * the `$sessionKey`. */ public static function createFromSession( SessionInterface $session, string $sessionKey = self::FLASH_NEXT ) : FlashMessagesInterface; /** * Set a flash value with the given key. * * Flash values are accessible on the next \"hop\", where a hop is the * next time the session is accessed; you may pass an additional $hops * integer to allow access for more than one hop. * * @param mixed $value */ public function flash(string $key, $value, int $hops = 1) : void; /** * Set a flash value with the given key, but allow access during this request. * * Flash values are generally accessible only on subsequent requests; * using this method, you may make the value available during the current * request as well. * * @param mixed $value */ public function flashNow(string $key, $value, int $hops = 1) : void; /** * Retrieve a flash value. * * Will return a value only if a flash value was set in a previous request, * or if `flashNow()` was called in this request with the same `$key`. * * WILL NOT return a value if set in the current request via `flash()`. * * @param mixed $default Default value to return if no flash value exists. * @return mixed */ public function getFlash(string $key, $default = null); /** * Retrieve all flash values. * * Will return all values was set in a previous request, or if `flashNow()` * was called in this request. * * WILL NOT return values set in the current request via `flash()`. * * @return array */ public function getFlashes() : array; /** * Clear all flash values. * * Affects the next and subsequent requests. */ public function clearFlash() : void; /** * Prolongs any current flash messages for one more hop. */ public function prolongFlash() : void; } A default implementation is provided in the class Zend\\Expressive\\Flash\\FlashMessages , but you may implement the interface yourself if you have special needs that fall outside this standard implementation. The instance will generally be injected into your request under the attribute Zend\\Expressive\\Flash\\FlashMessageMiddleware::FLASH_ATTRIBUTE , which evaluates to flash .","title":"Flash Messages"},{"location":"messages/#usage","text":"First, pull the flash messages from the request: $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE); // or $flashMessages = $request->getAttribute('flash'); To create a flash message for the next request: $flashMessages->flash($messageName, $messageValue); To retrieve a message you previously flashed: $message = $flashMessages->getFlash($messageName); To retrieve all messages you previously flashed: $messages = $flashMessages->getFlashes();","title":"Usage"},{"location":"messages/#hops","text":"Sometimes you may want a flash message to persist for longer than a single request. As an example, with a multi-page form, you may want to store messages until all pages have been filled. zend-expressive-flash allows you to specify hops , indicating how many requests the flash message will persist for. The default value is 1 , indicating a single hop. This value is provided when you call flash() as an optional third argument. To have a message persist for three \"hops\", you might call flash() as follows: $flashMessages->flash($messageName, $messageValue, 3); Sometimes you may want to ensure all messages persist for one more hop. To do that: $flashMessages->prolongFlash(); If you want to clear all flash methods, no matter the number of hops: $flashMessages->clearFlash(); Note, however, that this clears them for the next request , not the current one.","title":"Hops"},{"location":"messages/#accessing-messages-in-the-current-request","text":"When you create a flash message, it is available in the next request , but not the current request . If you want access to it in the current request as well, use the flashNow() method instead of flash() : $flashMessages->flashNow($messageName, $messageValue); The signature of this method is the same as for flash() , and allows you to optionally provide a $hops value as well.","title":"Accessing messages in the current request"},{"location":"middleware/","text":"Flash Message Middleware In order to provide flash messages to your middleware, you will first need to register Zend\\Expressive\\Flash\\FlashMessageMiddleware in your application pipeline or routed middleware pipeline; additionally, you'll need to ensure Zend\\Expressive\\Session\\SessionMiddleware is registered prior to it. This middleware does the following: Pulls the session container from the request via the attribute Zend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE (\"session\"). Passes the container, along with a defined session key, to a factory for generating a FlashMessagesInterface instance. Passes that instance to a request that the delegate processes, using another request attribute. Default configuration By default, FlashMessageMiddleware uses FlashMessages::createFromSession() to generate the flash messages container, the key Zend\\Expressive\\Flash\\FlashMessagesInterface::FLASH_NEXT (this is a literal string) to pull stored flash messages from the session, and the request attribute FlashMessageMiddleware::FLASH_ATTRIBUTE (\"flash\") to pass the flash messages container to the next middleware. If you are using the zend-component-installer Composer plugin, the middleware will already be wired for you. Otherwise, you will need to map the middleware to your dependency injection container as an invokable (no constructor arguments). If these defaults will work for you, you have no further configuration to do. Custom configuration If you want to specify a different flash messages container implementation, a different session key, or a different flash messages request attribute name, you will need to create a new factory for your FlashMessagesMiddleware . As an example, in the following, I specify: Application\\FlashMessages as the flash messages container; this class will need to implement FlashMessagesInterface , including the static method createFromSession() . The string Application\\FlashMessages::FLASH_NEXT as the session key in which flash messages will be stored. The request attribute flash-messages in which to store the flash messages container. use Application\\FlashMessages; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Flash\\FlashMessageMiddleware; class FlashMessageMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new FlashMessageMiddleware( FlashMessages::class, FlashMessages::class . '::FLASH_NEXT', 'flash-messages' ); } } Once you have created this factory, map the FlashMessageMiddleware to it in your dependency injection configuration: 'dependencies' => [ 'factories' => [ \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class => FlashMessageMiddlewareFactory::class, ], ], Piping the middleware You may pipe this middleware either in your application pipeline ( config/pipeline.php ) or a routed middleware pipeline ( config/routes.php , or a delegator factory). When you do, you MUST register it AFTER the Zend\\Expressive\\Session\\SessionMiddleware as it depends on that middleware for its session container. As an example within an application pipeline: $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class); Within a routed middleware definition: $app->post('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class, LoginHandler::class, ]);","title":"Flash Message Middleware"},{"location":"middleware/#flash-message-middleware","text":"In order to provide flash messages to your middleware, you will first need to register Zend\\Expressive\\Flash\\FlashMessageMiddleware in your application pipeline or routed middleware pipeline; additionally, you'll need to ensure Zend\\Expressive\\Session\\SessionMiddleware is registered prior to it. This middleware does the following: Pulls the session container from the request via the attribute Zend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE (\"session\"). Passes the container, along with a defined session key, to a factory for generating a FlashMessagesInterface instance. Passes that instance to a request that the delegate processes, using another request attribute.","title":"Flash Message Middleware"},{"location":"middleware/#default-configuration","text":"By default, FlashMessageMiddleware uses FlashMessages::createFromSession() to generate the flash messages container, the key Zend\\Expressive\\Flash\\FlashMessagesInterface::FLASH_NEXT (this is a literal string) to pull stored flash messages from the session, and the request attribute FlashMessageMiddleware::FLASH_ATTRIBUTE (\"flash\") to pass the flash messages container to the next middleware. If you are using the zend-component-installer Composer plugin, the middleware will already be wired for you. Otherwise, you will need to map the middleware to your dependency injection container as an invokable (no constructor arguments). If these defaults will work for you, you have no further configuration to do.","title":"Default configuration"},{"location":"middleware/#custom-configuration","text":"If you want to specify a different flash messages container implementation, a different session key, or a different flash messages request attribute name, you will need to create a new factory for your FlashMessagesMiddleware . As an example, in the following, I specify: Application\\FlashMessages as the flash messages container; this class will need to implement FlashMessagesInterface , including the static method createFromSession() . The string Application\\FlashMessages::FLASH_NEXT as the session key in which flash messages will be stored. The request attribute flash-messages in which to store the flash messages container. use Application\\FlashMessages; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Flash\\FlashMessageMiddleware; class FlashMessageMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new FlashMessageMiddleware( FlashMessages::class, FlashMessages::class . '::FLASH_NEXT', 'flash-messages' ); } } Once you have created this factory, map the FlashMessageMiddleware to it in your dependency injection configuration: 'dependencies' => [ 'factories' => [ \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class => FlashMessageMiddlewareFactory::class, ], ],","title":"Custom configuration"},{"location":"middleware/#piping-the-middleware","text":"You may pipe this middleware either in your application pipeline ( config/pipeline.php ) or a routed middleware pipeline ( config/routes.php , or a delegator factory). When you do, you MUST register it AFTER the Zend\\Expressive\\Session\\SessionMiddleware as it depends on that middleware for its session container. As an example within an application pipeline: $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class); Within a routed middleware definition: $app->post('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class, LoginHandler::class, ]);","title":"Piping the middleware"}]}